<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Private Maps</title>
	<link rel="stylesheet" href="styles/styles.css" />
</head>

<body>
	<canvas id="mapCanvas"></canvas>
	<div class="controls">
		<h1>Private Maps</h1>
		<input id="start" type="text" placeholder="Enter start location" />
		<input id="end" type="text" placeholder="Enter end location" />
		<button id="Run">Find Shortest Path</button>
	</div>

	<script type="module">
		import { Point } from "./scripts/point.ts";
		import { Edge } from "./scripts/edge.ts";
		import { Graph } from "./scripts/graph.ts";
		import { OsmLoader } from "./scripts/osmLoader.ts";
		import { Viewport } from "./scripts/viewport.ts";
		import { aStar } from "./scripts/aStar.ts";
		import { Path } from "./scripts/path.ts";
		import { Djikstra } from "./scripts/djikstra.ts";
		import { PathFinding } from "./scripts/pathfinding.ts";
		import { TileManager } from "./scripts/tileManager.ts";
		import { geoCoder } from "./scripts/geoCoder.ts";


		const mapCanvas = document.getElementById("mapCanvas");
		mapCanvas.width = window.innerWidth;
		mapCanvas.height = window.innerHeight;

		window.addEventListener("resize", () => {
			mapCanvas.width = window.innerWidth;
			mapCanvas.height = window.innerHeight;
			throttleRender();
		});

		const ctx = mapCanvas.getContext("2d");
		const viewport = new Viewport(mapCanvas);
		var fpath = null;

		const loader = new OsmLoader();
		const graph = await loader.load();


		// Compute bounding box
		let latMin = Infinity,
			latMax = -Infinity;
		let lonMin = Infinity,
			lonMax = -Infinity;
		graph.points.forEach((p) => {
			if (p.lat < latMin) latMin = p.lat;
			if (p.lat > latMax) latMax = p.lat;
			if (p.lon < lonMin) lonMin = p.lon;
			if (p.lon > lonMax) lonMax = p.lon;
		});
		viewport.autoFit(latMin, latMax, lonMin, lonMax);

		function render() {
			ctx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);
			graph.draw(ctx, viewport);
			if (fpath) { fpath.draw(ctx, viewport); }

		}
		render();

		// Mouse events for panning
		let isDragging = false;
		let lastX = 0,
			lastY = 0;

		mapCanvas.addEventListener("mousedown", (e) => {
			isDragging = true;
			lastX = e.clientX;
			lastY = e.clientY;
		});

		mapCanvas.addEventListener("mousemove", (e) => {
			if (!isDragging) return;
			const dx = e.clientX - lastX;
			const dy = e.clientY - lastY;
			viewport.pan(dx, dy);
			lastX = e.clientX;
			lastY = e.clientY;
			render();
		});

		mapCanvas.addEventListener("mouseup", () => (isDragging = false));

		// Wheel event for zoom
		mapCanvas.addEventListener(
			"wheel",
			(e) => {
				e.preventDefault();
				const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
				viewport.zoom(zoomFactor);
				render();
			},
			{ passive: false }
		);

		const runButton = document.getElementById("Run");
		runButton.addEventListener("click", async () => {

			const start = document.getElementById("start").value;
			const end = document.getElementById("end").value;
			const geocoder = new geoCoder();
			try {
				const startCoords = await geocoder.run(start);
				const endCoords = await geocoder.run(end);
				console.log("Start Coords:", startCoords);
				console.log("End Coords:", endCoords);

				//make the start and end coords snap to the nearest point
				const startpoint = graph.placePointOnEdge(startCoords.y, startCoords.x);
				const endpoint = graph.placePointOnEdge(endCoords.y, endCoords.x);


				const pathfinding = new PathFinding(graph, startpoint, endpoint);
				console.log("Running PathFinding from", startpoint, "to", endpoint);

				const result = pathfinding.run();
				const path = result.bestPath;
				const algo = result.algorithm;
				console.log("Pathfinding algorithm used:", algo);
				console.log("PathFinding path points:", path);


				//console.log("PathFinding path points:", pathPoints); // Add debugging here
				fpath = path;
			}
			catch (e) {
				console.log("Error:", e);
			}


			render();
		});
	</script>
</body>

</html>